var documenterSearchIndex = {"docs":
[{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graphterm.jl\"","category":"page"},{"location":"generated/core/graphterm/#Making-instances-1","page":"Making instances","title":"Making instances","text":"","category":"section"},{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf_no_level.jl\"","category":"page"},{"location":"generated/theories/cwf_no_level/#Categories-with-Families-(no-universe-levels)-1","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"","category":"section"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/preorder.jl\"","category":"page"},{"location":"generated/theories/preorder/#Preorder-1","page":"Preorder","title":"Preorder","text":"","category":"section"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"print(render(AlgebraicTypeTheory.Theories.preorder))","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf.jl\"","category":"page"},{"location":"generated/theories/cwf/#Categories-with-Families-1","page":"Categories with Families","title":"Categories with Families","text":"","category":"section"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cat.jl\"","category":"page"},{"location":"generated/theories/cat/#Categories-1","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"print(render(AlgebraicTypeTheory.Theories.cat))","category":"page"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graph.jl\"","category":"page"},{"location":"generated/core/graph/#Core-datatypes-1","page":"Core datatypes","title":"Core datatypes","text":"","category":"section"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/boolean.jl\"","category":"page"},{"location":"generated/theories/boolean/#Boolean-Algebra-1","page":"Boolean Algebra","title":"Boolean Algebra","text":"","category":"section"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"print(render(AlgebraicTypeTheory.Theories.boolalg))","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/monoid.jl\"","category":"page"},{"location":"generated/theories/monoid/#Monoid-1","page":"Monoid","title":"Monoid","text":"","category":"section"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"print(render(AlgebraicTypeTheory.Theories.monoid))","category":"page"},{"location":"#AlgebraicTypeTheory.jl-1","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"So far, encoding material from this tutorial and this paper by Jonathan Sterling.","category":"page"},{"location":"#Goals-1","page":"AlgebraicTypeTheory.jl","title":"Goals","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"[x] To experiment with ideas that might be useful for Catlab.jl.\n[x] To construct theories, which are collections of sort declarations, (term) operation declarations, and equality axioms (between sorts and/or terms).\n[x] To instantiate theories using Julia types and functions, so that terms of the theory can be concretely evaluated.\n[ \\ ] To use a theory to rewrite terms of that theory in a normal form.\n[  ] Test (by exhaustive or random search) that instances of theories satisfy their axioms\n[  ] To represent homomorphisms between theories and to be able to compose these to get new instances from old ones.\n[  ] To look at the structure of some theories and automatically infer some natural morphisms (e.g. an injection from a strictly smaller theory).\n[  ] To organize a collection of theories into a queryable knowledge base.\n[  ]To use macros to make the writing of equations/theories more convenient. E.g.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"   App(:mul, [\n      App(:mul, [\n         App(:mul, [\n               App(:mul, [\n                  App(:mul,[\n                     App(:id),\n                     X]),\n                  Y]),\n               Z]),\n         App(:id)]),\n      X])","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"could be written as @term (((((id() * X) * Y) * Z) * id()) * X)","category":"page"},{"location":"#Status-1","page":"AlgebraicTypeTheory.jl","title":"Status","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Theories: implementations for Boolean algebras, preorders, monoids, categories, an algebraicized Martin-Löf type theory (not complete yet).","category":"page"},{"location":"#Overview-1","page":"AlgebraicTypeTheory.jl","title":"Overview","text":"","category":"section"},{"location":"#Terms,-Patterns,-Rewrite-rules-1","page":"AlgebraicTypeTheory.jl","title":"Terms, Patterns, Rewrite rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Take the theory of categories and let Ob=Sort(:Ob); A,B,C,X,Y,Z = [Var(x, Ob) for x in [:A,:B,:C,:X,:Y,:Z]] so that we can create a term: Var(:f, Sort(:Hom,[A,B]))","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/f.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define composition by providing the output sort and then the sorts of arguments: OpDecl(:cmp, Sort(:Hom,[X,Z]), [Sort(:Hom,[X,Y])]),Sort(:Hom,[Y,Z])]) Here the variables actually signify wildcards, so these terms gets automatically turned into patterns with named wildcards and a new dark cross symbol which means \"I have a term (arg #2) of a certain sort (arg #1)\". This is what the output sort looks like:","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/homxzpat.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Now we can compute the sort of arbitrary expressions that match this pattern. So using a theory we can \"upgrade\" a term like App(:cmp,[App(:id,[A]), Var(:f,Sort(:Hom,[A,B]))]):","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idf.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"...to a \"sorted version\":","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfinferred.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can then create pattern out of this and f by itself to make a rule: Rule(\"⋅ left-identity\", f, App(:cmp, [idA,f])) which can perform the left rewrite identity on any graph term of an identity composed with something.","category":"page"},{"location":"#Normalization-rules-1","page":"AlgebraicTypeTheory.jl","title":"Normalization rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"A naive normalization algorithm is implemented to simplify terms, hopefully to a normal form (if the axioms, interpreted as rewrite rules, are confluent and terminating). It tries to apply all rules to all nodes in the tree, restarting when a change is made. If a cycle is detected, then the process stops and returns the lexicographic maximum (to resolve (X+Y)<->(Y+X) infinite loops and others). Examples, including ((id(A) ⋅ ((ab ⋅ bc) ⋅ id(C))) ⋅ (id(C) ⋅ (id(C) ⋅ cd))) -> ((ab ⋅ bc) ⋅ cd), are in a test file.","category":"page"},{"location":"#Computing-with-GATs-1","page":"AlgebraicTypeTheory.jl","title":"Computing with GATs","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define an instance of a theory by mapping (possibly parameterized) types to sorts and functions to the term operations. In a test file there are examples of implementing Monoids with (Int,*), Boolean algebras with the powerset of {1,2,3} and union/intersection/complement, and Categories with 2D matrix multiplication. For instance, the following term can be evaluated in an environment where f=[1, 2, 3; 4, 5, 6], g=[1;1;1], M=ℤ², N=ℤ³, P=ℤ","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfg.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"to obtain the composite [6; 15] which transforms from ℤ² to ℤ. We can reduce the number of computations by reducing the expression using Cat's rewrite rules before evaluating.","category":"page"}]
}
