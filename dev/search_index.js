var documenterSearchIndex = {"docs":
[{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graphterm.jl\"","category":"page"},{"location":"generated/core/graphterm/#Making-instances-1","page":"Making instances","title":"Making instances","text":"","category":"section"},{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf_no_level.jl\"","category":"page"},{"location":"generated/theories/cwf_no_level/#Categories-with-Families-(no-universe-levels)-1","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"","category":"section"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/preorder.jl\"","category":"page"},{"location":"generated/theories/preorder/#Preorder-1","page":"Preorder","title":"Preorder","text":"","category":"section"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"print(render(AlgebraicTypeTheory.Theories.preorder))","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf.jl\"","category":"page"},{"location":"generated/theories/cwf/#Categories-with-Families-1","page":"Categories with Families","title":"Categories with Families","text":"","category":"section"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cat.jl\"","category":"page"},{"location":"generated/theories/cat/#Categories-1","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"print(render(AlgebraicTypeTheory.Theories.cat))","category":"page"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graph.jl\"","category":"page"},{"location":"generated/core/graph/#Core-datatypes-1","page":"Core datatypes","title":"Core datatypes","text":"","category":"section"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/boolean.jl\"","category":"page"},{"location":"generated/theories/boolean/#Boolean-Algebra-1","page":"Boolean Algebra","title":"Boolean Algebra","text":"","category":"section"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"print(render(AlgebraicTypeTheory.Theories.boolalg))","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/monoid.jl\"","category":"page"},{"location":"generated/theories/monoid/#Monoid-1","page":"Monoid","title":"Monoid","text":"","category":"section"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"print(render(AlgebraicTypeTheory.Theories.monoid))","category":"page"},{"location":"#AlgebraicTypeTheory.jl-1","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"So far, encoding material from this tutorial and this paper by Jonathan Sterling.","category":"page"},{"location":"#Goals-1","page":"AlgebraicTypeTheory.jl","title":"Goals","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"[x] To experiment with ideas that might be useful for Catlab.jl.\n[x] To construct theories, which are collections of sort declarations, (term) operation declarations, and equality axioms (between sorts and/or terms).\n[x] To instantiate theories using Julia types and functions, so that terms of the theory can be concretely evaluated.\n[ \\ ] To use a theory to rewrite terms of that theory in a normal form.\n[  ] Test (by exhaustive or random search) that instances of theories satisfy their axioms\n[  ] To represent homomorphisms between theories and to be able to compose these to get new instances from old ones.\n[  ] To look at the structure of some theories and automatically infer some natural morphisms (e.g. an injection from a strictly smaller theory).\n[  ] To organize a collection of theories into a queryable knowledge base.\n[  ]To use macros to make the writing of equations/theories more convenient. E.g.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"   App(:mul, [\n      App(:mul, [\n         App(:mul, [\n               App(:mul, [\n                  App(:mul,[\n                     App(:id),\n                     X]),\n                  Y]),\n               Z]),\n         App(:id)]),\n      X])","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"could be written as @term (((((id() * X) * Y) * Z) * id()) * X)","category":"page"},{"location":"#Status-1","page":"AlgebraicTypeTheory.jl","title":"Status","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Theories: implementations for Boolean algebras, preorders, monoids, categories, an algebraicized Martin-LÃ¶f type theory (not complete yet).","category":"page"},{"location":"#Overview-1","page":"AlgebraicTypeTheory.jl","title":"Overview","text":"","category":"section"},{"location":"#Terms,-Patterns,-Rewrite-rules-1","page":"AlgebraicTypeTheory.jl","title":"Terms, Patterns, Rewrite rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Take the theory of categories and create a term: Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:A,Ob)])) (using Ob=Sort(:Ob))","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/f.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define composition by providing the output sort, Sort(:Hom,[Var(:X,Ob),Var(:Z,Ob)]). Here the variables actually are meant to be wildcards, so we can create a new symbol in our graph to mean \"something (arg #2) of a certain sort (arg #1)\" and let the \"something\" be matchable with anything.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/homxzpat.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"The variable names were significant (note each wildcard has a name) since these names can be bound in the arguments of the declaration of composition, which are Var(:m,Sort(:Hom,[Var(:X,Ob),Var(:Y,Ob)])]) and Var(:n,Sort(:Hom,[Var(:Y,Ob),Var(:Z,Ob)])]) (the variable names m and n only matter for printing out the operator declaration, and all that was important for Y was that it was the same in the two arguments). Now we can compute the sort of arbitrary expressions that match this pattern. So using a theory we can \"upgrade\" a term like App(:cmp,[App(:id,[Var(:A,Ob)]), Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:B,Ob)]))]):","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idf.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"...to a \"sorted version\":","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfinferred.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can then create pattern out of this and f by itself to make a rule: Rule(\"â left-identity\", f, App(:cmp, [idA,f])) which can perform the left rewrite identity on any graph term of an identity composed with something.","category":"page"},{"location":"#Example-theory-1","page":"AlgebraicTypeTheory.jl","title":"Example theory","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Sort declarations, term operation declarations, and axioms all can be rendered in plain text, and sorts/terms/patterns may as viewed as term graphs. For example, this fragment of categories with families + dependent types.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"\n################################\n# ******* Theory: cwf ******* #\n################################\n\n4 sorts, 13 ops, 14 rules\n\n#########\n# Sorts #\n#########\n\n==================================================\n\n---------   Ctx\nCtx  sort\n\nContexts: Concretely, a mapping xáµ¢:Xáµ¢ of free variables to types.\nConsider these as objects in a category C.\n\n\n==================================================\n   Î:Ctx\n-----------   Ty\nTy(Î)  sort\n\nThe sort of types in context Î\n\n\n==================================================\n A,B:Ctx\n---------   Hom\nAâB  sort\n\nSubstitutions between contexts: concretely, a substitution báµ¢:Î²áµ¢â¦aáµ¢:Î±áµ¢.\nConsider these as morphisms in the category C.\n\n\n==================================================\nA:Ty(Î)  Î:Ctx\n--------------   el\nðð¥(Îâ¢A)  sort\n\nThe sort of terms of type A (in ctx Î), where A is of size Î±\n 'This is to fix a dependent presheaf El: Psh(ctx)/Ty, i.e. a nat. trans. Ï: ElâTy'\n\n\n##############\n# Operations #\n##############\n\n==================================================\nA:Ty(Î)  Î:Ctx\n--------------   ext\n (Î.A) : Ctx\n\nContext compreshension operation\n\n\n==================================================\nB:Ty((Î.A))  A:Ty(Î)  Î:Ctx\n---------------------------   Pi\n      Î (A,B) : Ty(Î)\n\nÎ  formation\n\n\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  Î,Î:Ctx\n-----------------------   Tyact\n     A[Î³] : Ty(Î)\n\nSubstitution action: apply the substitution Î³ (of type ÎâÎ) to a some type A (in ctx Î) to obtain a term of type Î\n\n\n==================================================\n\n-------   emp\nâ : Ctx\n\nThe category C has a terminal object: the empty context\n\n\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  Î,Î:Ctx  a:ðð¥(Îâ¢A)\n----------------------------------   Elact\n        a[Î³] : ðð¥(Îâ¢A[Î³])\n\nSubstitution action: apply the substitution Î³ (of type ÎâÎ) to a term of type A (in ctx Î)\nResult: a term of type A[Î³] (in ctx Î)\n\n\n==================================================\nB:Ty((Î.A))  A:Ty(Î)  M:ðð¥((Î.A)â¢B)  Î:Ctx\n------------------------------------------   lam\n           Î»(M) : ðð¥(Îâ¢Î (A,B))\n\nÎ  introduction\n\n\n==================================================\nB:Ty((Î.A))  A:Ty(Î)  M:ðð¥(Îâ¢Î (A,B))  N:ðð¥(Îâ¢A[id(Î)])  Î:Ctx\n-------------------------------------------------------------   app\n                ðð©ð©(M,N) : ðð¥(Îâ¢B[â¨id(Î),Nâ©])\n\nPi elimination via application\n\n==================================================\nf:AâB  g:BâC  A,B,C:Ctx\n-----------------------   cmp\n      (fâg) : AâC\n\nComposition, only defined for pairs of morphisms that match head-to-tail, is an associative operation which picks out a third.\n\n==================================================\n    Î:Ctx\n--------------   empsubst\n!(Î) : Îâemp()\n\nSubstitution into an empty context\n\n==================================================\nA:Ty(Î)  Î:Ctx\n--------------   p\nð©(A) : (Î.A)âÎ\n\nProjection function 'drop'???\n\n==================================================\n     A:Ty(Î)  Î:Ctx\n------------------------   q\nðª(A) : ðð¥((Î.A)â¢A[ð©(A)])\n\nProjection function 'var'???\n\n\n###################\n# Equality Axioms #\n###################\n==================================================\n  Î·:Îâemp()  Î:Ctx\n--------------------   ! unique\n!(Î) = Î·   : Îâemp()\n\nSubstitution into an empty context is unique.\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  B:Ty((Î.A))  M:ðð¥((Î.A)â¢B)  Î,Î:Ctx\n---------------------------------------------------   Lambda Substitution\n Î»(M)[Î³] = M[â¨(ð©(A)âÎ³),ðª(A)â©]   : ðð¥(Îâ¢Î (A,B)[Î³])\n\n==================================================\n      Î³:ÎâÎ  A:Ty(Î)  B:Ty((Î.A))  Î,Î:Ctx\n------------------------------------------------   Pi substitution\nÎ (A,B)[Î³] = Î (A[Î³],B[â¨(ð©(A)âÎ³),ðª(A)â©])   : Ty(Î)\n\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  a:ðð¥(Îâ¢A)  Î´:ÎâÎ  Î,Î,Î:Ctx\n-------------------------------------------   Term substitution composition\n   a[(Î´âÎ³)] = a[Î³][Î´]   : ðð¥(Îâ¢A[(Î´âÎ³)])\n\nThe functor to Fam from C preserves composition of substitutions:\nApplying two substitutions in sequence is the same as applying the composition of the substitutions in C\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  N:ðð¥(Îâ¢A[Î³])  Î,Î:Ctx\n-------------------------------------   Universal property of ð©\n      Î³ = (â¨Î³,Nâ©âð©(A))   : ÎâÎ\n\n==================================================\nÎ³:ÎâÎ  A:Ty(Î)  N:ðð¥(Îâ¢A[Î³])  Î,Î:Ctx\n-------------------------------------   Universal property of ðª\n   N = ðª(A)[â¨Î³,Nâ©]   : ðð¥(Îâ¢A[Î³])\n==================================================\n            A:Ty(Î)  Î:Ctx\n---------------------------------------   ð©ðª property\nid((Î.A)) = â¨ð©(A),ðª(A)â©   : (Î.A)â(Î.A)","category":"page"},{"location":"#Normalization-rules-1","page":"AlgebraicTypeTheory.jl","title":"Normalization rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"A naive normalization algorithm is implemented to simplify terms, hopefully to a normal form (if the axioms, interpreted as rewrite rules, are confluent and terminating). It tries to apply all rules to all nodes in the tree, restarting when a change is made. If a cycle is detected, then the process stops and returns the lexicographic maximum (to resolve (X+Y)<->(Y+X) infinite loops and others). Examples, including ((id(A) â ((ab â bc) â id(C))) â (id(C) â (id(C) â cd))) -> ((ab â bc) â cd), are in a test file.","category":"page"},{"location":"#Computing-with-GATs-1","page":"AlgebraicTypeTheory.jl","title":"Computing with GATs","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define an instance of a theory by mapping (possibly parameterized) types to sorts and functions to the term operations. In a test file there are examples of implementing Monoids with (Int,*), Boolean algebras with the powerset of {1,2,3} and union/intersection/complement, and Categories with 2D matrix multiplication. For instance, the following term can be evaluated in an environment where f=[1, 2, 3; 4, 5, 6], g=[1;1;1], M=â¤Â², N=â¤Â³, P=â¤","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfg.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"to obtain the composite [6; 15] which transforms from â¤Â² to â¤. We can reduce the number of computations by reducing the expression using Cat's rewrite rules before evaluating.","category":"page"}]
}
