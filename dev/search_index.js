var documenterSearchIndex = {"docs":
[{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graphterm.jl\"","category":"page"},{"location":"generated/core/graphterm/#Making-instances-1","page":"Making instances","title":"Making instances","text":"","category":"section"},{"location":"generated/core/graphterm/#","page":"Making instances","title":"Making instances","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf_no_level.jl\"","category":"page"},{"location":"generated/theories/cwf_no_level/#Categories-with-Families-(no-universe-levels)-1","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"","category":"section"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf_no_level/#","page":"Categories with Families (no universe levels)","title":"Categories with Families (no universe levels)","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/preorder.jl\"","category":"page"},{"location":"generated/theories/preorder/#Preorder-1","page":"Preorder","title":"Preorder","text":"","category":"section"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/preorder/#","page":"Preorder","title":"Preorder","text":"print(render(AlgebraicTypeTheory.Theories.preorder))","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cwf.jl\"","category":"page"},{"location":"generated/theories/cwf/#Categories-with-Families-1","page":"Categories with Families","title":"Categories with Families","text":"","category":"section"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cwf/#","page":"Categories with Families","title":"Categories with Families","text":"print(render(AlgebraicTypeTheory.Theories.cwf))","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/cat.jl\"","category":"page"},{"location":"generated/theories/cat/#Categories-1","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/cat/#","page":"Categories","title":"Categories","text":"print(render(AlgebraicTypeTheory.Theories.cat))","category":"page"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/core/graph.jl\"","category":"page"},{"location":"generated/core/graph/#Core-datatypes-1","page":"Core datatypes","title":"Core datatypes","text":"","category":"section"},{"location":"generated/core/graph/#","page":"Core datatypes","title":"Core datatypes","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/boolean.jl\"","category":"page"},{"location":"generated/theories/boolean/#Boolean-Algebra-1","page":"Boolean Algebra","title":"Boolean Algebra","text":"","category":"section"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/boolean/#","page":"Boolean Algebra","title":"Boolean Algebra","text":"print(render(AlgebraicTypeTheory.Theories.boolalg))","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"EditURL = \"https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/literate/theories/monoid.jl\"","category":"page"},{"location":"generated/theories/monoid/#Monoid-1","page":"Monoid","title":"Monoid","text":"","category":"section"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"if isdefined(@__MODULE__, :LanguageServer)\n    include(\"../../../src/AlgebraicTypeTheory.jl\")\nend\n\nusing AlgebraicTypeTheory","category":"page"},{"location":"generated/theories/monoid/#","page":"Monoid","title":"Monoid","text":"print(render(AlgebraicTypeTheory.Theories.monoid))","category":"page"},{"location":"#AlgebraicTypeTheory.jl-1","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"So far, encoding material from this tutorial and this paper by Jonathan Sterling.","category":"page"},{"location":"#Goals-1","page":"AlgebraicTypeTheory.jl","title":"Goals","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"[x] To experiment with ideas that might be useful for Catlab.jl.\n[x] To construct theories, which are collections of sort declarations, (term) operation declarations, and equality axioms (between sorts and/or terms).\n[x] To instantiate theories using Julia types and functions, so that terms of the theory can be concretely evaluated.\n[ \\ ] To use a theory to rewrite terms of that theory in a normal form.\n[  ] Test (by exhaustive or random search) that instances of theories satisfy their axioms\n[  ] To represent homomorphisms between theories and to be able to compose these to get new instances from old ones.\n[  ] To look at the structure of some theories and automatically infer some natural morphisms (e.g. an injection from a strictly smaller theory).\n[  ] To organize a collection of theories into a queryable knowledge base.\n[  ]To use macros to make the writing of equations/theories more convenient. E.g.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"   App(:mul, [\n      App(:mul, [\n         App(:mul, [\n               App(:mul, [\n                  App(:mul,[\n                     App(:id),\n                     X]),\n                  Y]),\n               Z]),\n         App(:id)]),\n      X])","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"could be written as @term (((((id() * X) * Y) * Z) * id()) * X)","category":"page"},{"location":"#Status-1","page":"AlgebraicTypeTheory.jl","title":"Status","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Theories: implementations for Boolean algebras, preorders, monoids, categories, an algebraicized Martin-LÃ¶f type theory (not complete yet).","category":"page"},{"location":"#Overview-1","page":"AlgebraicTypeTheory.jl","title":"Overview","text":"","category":"section"},{"location":"#Terms,-Patterns,-Rewrite-rules-1","page":"AlgebraicTypeTheory.jl","title":"Terms, Patterns, Rewrite rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Take the theory of categories and create a term: Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:A,Ob)])) (using Ob=Sort(:Ob))","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/f.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define composition by providing the output sort, Sort(:Hom,[Var(:X,Ob),Var(:Z,Ob)]). Here the variables actually are meant to be wildcards, so we can create a new symbol in our graph to mean \"something (arg #2) of a certain sort (arg #1)\" and let the \"something\" be matchable with anything.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/homxzpat.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"The variable names were significant (note each wildcard has a name) since these names can be bound in the arguments of the declaration of composition, which are Var(:m,Sort(:Hom,[Var(:X,Ob),Var(:Y,Ob)])]) and Var(:n,Sort(:Hom,[Var(:Y,Ob),Var(:Z,Ob)])]) (the variable names m and n only matter for printing out the operator declaration, and all that was important for Y was that it was the same in the two arguments). Now we can compute the sort of arbitrary expressions that match this pattern. So using a theory we can \"upgrade\" a term like App(:cmp,[App(:id,[Var(:A,Ob)]), Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:B,Ob)]))]):","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idf.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"...to a \"sorted version\":","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfinferred.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can then create pattern out of this and f by itself to make a rule: Rule(\"â‹… left-identity\", f, App(:cmp, [idA,f])) which can perform the left rewrite identity on any graph term of an identity composed with something.","category":"page"},{"location":"#Example-theory-1","page":"AlgebraicTypeTheory.jl","title":"Example theory","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"Sort declarations, term operation declarations, and axioms all can be rendered in plain text, and sorts/terms/patterns may as viewed as term graphs. For example, this fragment of categories with families + dependent types.","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"\n################################\n# ******* Theory: cwf ******* #\n################################\n\n4 sorts, 13 ops, 14 rules\n\n#########\n# Sorts #\n#########\n\n==================================================\n\n---------   Ctx\nCtx  sort\n\nContexts: Concretely, a mapping xáµ¢:Xáµ¢ of free variables to types.\nConsider these as objects in a category C.\n\n\n==================================================\n   Î“:Ctx\n-----------   Ty\nTy(Î“)  sort\n\nThe sort of types in context Î“\n\n\n==================================================\n A,B:Ctx\n---------   Hom\nAâ†’B  sort\n\nSubstitutions between contexts: concretely, a substitution báµ¢:Î²áµ¢â†¦aáµ¢:Î±áµ¢.\nConsider these as morphisms in the category C.\n\n\n==================================================\nA:Ty(Î“)  Î“:Ctx\n--------------   el\nğ„ğ¥(Î“âŠ¢A)  sort\n\nThe sort of terms of type A (in ctx Î“), where A is of size Î±\n 'This is to fix a dependent presheaf El: Psh(ctx)/Ty, i.e. a nat. trans. Ï€: Elâ†’Ty'\n\n\n##############\n# Operations #\n##############\n\n==================================================\nA:Ty(Î“)  Î“:Ctx\n--------------   ext\n (Î“.A) : Ctx\n\nContext compreshension operation\n\n\n==================================================\nB:Ty((Î“.A))  A:Ty(Î“)  Î“:Ctx\n---------------------------   Pi\n      Î (A,B) : Ty(Î“)\n\nÎ  formation\n\n\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  Î“,Î”:Ctx\n-----------------------   Tyact\n     A[Î³] : Ty(Î”)\n\nSubstitution action: apply the substitution Î³ (of type Î”â†’Î“) to a some type A (in ctx Î“) to obtain a term of type Î”\n\n\n==================================================\n\n-------   emp\nâ‹… : Ctx\n\nThe category C has a terminal object: the empty context\n\n\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  Î“,Î”:Ctx  a:ğ„ğ¥(Î“âŠ¢A)\n----------------------------------   Elact\n        a[Î³] : ğ„ğ¥(Î”âŠ¢A[Î³])\n\nSubstitution action: apply the substitution Î³ (of type Î”â†’Î“) to a term of type A (in ctx Î“)\nResult: a term of type A[Î³] (in ctx Î”)\n\n\n==================================================\nB:Ty((Î“.A))  A:Ty(Î“)  M:ğ„ğ¥((Î“.A)âŠ¢B)  Î“:Ctx\n------------------------------------------   lam\n           Î»(M) : ğ„ğ¥(Î“âŠ¢Î (A,B))\n\nÎ  introduction\n\n\n==================================================\nB:Ty((Î“.A))  A:Ty(Î“)  M:ğ„ğ¥(Î“âŠ¢Î (A,B))  N:ğ„ğ¥(Î“âŠ¢A[id(Î“)])  Î“:Ctx\n-------------------------------------------------------------   app\n                ğšğ©ğ©(M,N) : ğ„ğ¥(Î“âŠ¢B[âŸ¨id(Î“),NâŸ©])\n\nPi elimination via application\n\n==================================================\nf:Aâ†’B  g:Bâ†’C  A,B,C:Ctx\n-----------------------   cmp\n      (fâ‹…g) : Aâ†’C\n\nComposition, only defined for pairs of morphisms that match head-to-tail, is an associative operation which picks out a third.\n\n==================================================\n    Î“:Ctx\n--------------   empsubst\n!(Î“) : Î“â†’emp()\n\nSubstitution into an empty context\n\n==================================================\nA:Ty(Î“)  Î“:Ctx\n--------------   p\nğ©(A) : (Î“.A)â†’Î“\n\nProjection function 'drop'???\n\n==================================================\n     A:Ty(Î“)  Î“:Ctx\n------------------------   q\nğª(A) : ğ„ğ¥((Î“.A)âŠ¢A[ğ©(A)])\n\nProjection function 'var'???\n\n\n###################\n# Equality Axioms #\n###################\n==================================================\n  Î·:Î“â†’emp()  Î“:Ctx\n--------------------   ! unique\n!(Î“) = Î·   : Î“â†’emp()\n\nSubstitution into an empty context is unique.\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  B:Ty((Î“.A))  M:ğ„ğ¥((Î“.A)âŠ¢B)  Î“,Î”:Ctx\n---------------------------------------------------   Lambda Substitution\n Î»(M)[Î³] = M[âŸ¨(ğ©(A)â‹…Î³),ğª(A)âŸ©]   : ğ„ğ¥(Î”âŠ¢Î (A,B)[Î³])\n\n==================================================\n      Î³:Î”â†’Î“  A:Ty(Î“)  B:Ty((Î“.A))  Î“,Î”:Ctx\n------------------------------------------------   Pi substitution\nÎ (A,B)[Î³] = Î (A[Î³],B[âŸ¨(ğ©(A)â‹…Î³),ğª(A)âŸ©])   : Ty(Î”)\n\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  a:ğ„ğ¥(Î“âŠ¢A)  Î´:Îâ†’Î”  Î“,Î”,Î:Ctx\n-------------------------------------------   Term substitution composition\n   a[(Î´â‹…Î³)] = a[Î³][Î´]   : ğ„ğ¥(ÎâŠ¢A[(Î´â‹…Î³)])\n\nThe functor to Fam from C preserves composition of substitutions:\nApplying two substitutions in sequence is the same as applying the composition of the substitutions in C\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  N:ğ„ğ¥(Î”âŠ¢A[Î³])  Î“,Î”:Ctx\n-------------------------------------   Universal property of ğ©\n      Î³ = (âŸ¨Î³,NâŸ©â‹…ğ©(A))   : Î”â†’Î“\n\n==================================================\nÎ³:Î”â†’Î“  A:Ty(Î“)  N:ğ„ğ¥(Î”âŠ¢A[Î³])  Î“,Î”:Ctx\n-------------------------------------   Universal property of ğª\n   N = ğª(A)[âŸ¨Î³,NâŸ©]   : ğ„ğ¥(Î”âŠ¢A[Î³])\n==================================================\n            A:Ty(Î“)  Î“:Ctx\n---------------------------------------   ğ©ğª property\nid((Î“.A)) = âŸ¨ğ©(A),ğª(A)âŸ©   : (Î“.A)â†’(Î“.A)","category":"page"},{"location":"#Normalization-rules-1","page":"AlgebraicTypeTheory.jl","title":"Normalization rules","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"A naive normalization algorithm is implemented to simplify terms, hopefully to a normal form (if the axioms, interpreted as rewrite rules, are confluent and terminating). It tries to apply all rules to all nodes in the tree, restarting when a change is made. If a cycle is detected, then the process stops and returns the lexicographic maximum (to resolve (X+Y)<->(Y+X) infinite loops and others). Examples, including ((id(A) â‹… ((ab â‹… bc) â‹… id(C))) â‹… (id(C) â‹… (id(C) â‹… cd))) -> ((ab â‹… bc) â‹… cd), are in a test file.","category":"page"},{"location":"#Computing-with-GATs-1","page":"AlgebraicTypeTheory.jl","title":"Computing with GATs","text":"","category":"section"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"We can define an instance of a theory by mapping (possibly parameterized) types to sorts and functions to the term operations. In a test file there are examples of implementing Monoids with (Int,*), Boolean algebras with the powerset of {1,2,3} and union/intersection/complement, and Categories with 2D matrix multiplication. For instance, the following term can be evaluated in an environment where f=[1, 2, 3; 4, 5, 6], g=[1;1;1], M=â„¤Â², N=â„¤Â³, P=â„¤","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"<iframe scrolling=\"no\" style=\"height: 625px;\" id=\"igraph\" style=\"border:none;\" seamless=\"seamless\" src=\"https://web.stanford.edu/~ksb/docs/idfg.html\" height=\"525\" width=\"100%\"></iframe>","category":"page"},{"location":"#","page":"AlgebraicTypeTheory.jl","title":"AlgebraicTypeTheory.jl","text":"to obtain the composite [6; 15] which transforms from â„¤Â² to â„¤. We can reduce the number of computations by reducing the expression using Cat's rewrite rules before evaluating.","category":"page"}]
}
