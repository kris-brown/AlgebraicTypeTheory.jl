<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AlgebraicTypeTheory.jl · AlgebraicTypeTheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AlgebraicTypeTheory.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AlgebraicTypeTheory.jl</a><ul class="internal"><li><a class="tocitem" href="#Goals-1"><span>Goals</span></a></li><li><a class="tocitem" href="#Status-1"><span>Status</span></a></li><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AlgebraicTypeTheory.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AlgebraicTypeTheory.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AlgebraicTypeTheory.jl-1"><a class="docs-heading-anchor" href="#AlgebraicTypeTheory.jl-1">AlgebraicTypeTheory.jl</a><a class="docs-heading-anchor-permalink" href="#AlgebraicTypeTheory.jl-1" title="Permalink"></a></h1><p>So far, encoding material from <a href="http://www.jonmsterling.com/pdfs/algebraic-type-theory-tutorial.pdf">this tutorial</a> and <a href="https://arxiv.org/abs/1902.08848">this paper</a> by Jonathan Sterling.</p><p>NOTE: this library is on hold due to working on a prerequisite problem, as described in the README of <a href="https://github.com/kris-brown/SMT_term_rewriting">this repo</a>. If unification modulo the axioms of a GAT can be satisfactorily resolved, then I can return to this.</p><h2 id="Goals-1"><a class="docs-heading-anchor" href="#Goals-1">Goals</a><a class="docs-heading-anchor-permalink" href="#Goals-1" title="Permalink"></a></h2><ul><li><p>[x] To experiment with ideas that might be useful for <a href="https://epatters.github.io/Catlab.jl/latest/">Catlab.jl</a>.</p></li><li><p>[x] To construct <em>theories</em>, which are collections of sort declarations, (term) operation declarations, and equality axioms (between sorts and/or terms).</p></li><li><p>[x] To <em>instantiate</em> theories using Julia types and functions, so that terms of the theory can be concretely evaluated.</p></li><li><p>[  ] To use a theory to rewrite terms of that theory in a normal form.</p></li><li><p>[  ] Test (by exhaustive or random search) that instances of theories satisfy their axioms</p></li><li><p>[  ] To represent homomorphisms between theories and to be able to compose these to get new instances from old ones.</p></li><li><p>[  ] To look at the structure of some theories and automatically infer some natural morphisms (e.g. an injection from a strictly smaller theory).</p></li><li><p>[  ] To organize a collection of theories into a queryable knowledge base.</p></li><li><p>[  ]To use macros to make the writing of equations/theories more convenient. E.g.</p></li></ul><pre><code class="language-none">   App(:mul, [
      App(:mul, [
         App(:mul, [
               App(:mul, [
                  App(:mul,[
                     App(:id),
                     X]),
                  Y]),
               Z]),
         App(:id)]),
      X])</code></pre><p>could be written as <code>@term (((((id() * X) * Y) * Z) * id()) * X)</code></p><h2 id="Status-1"><a class="docs-heading-anchor" href="#Status-1">Status</a><a class="docs-heading-anchor-permalink" href="#Status-1" title="Permalink"></a></h2><p>Theories: implementations for <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Boolean.jl">Boolean algebras</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Preorder.jl">preorders</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Monoid.jl">monoids</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Cat.jl">categories</a>, an <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Cwf.jl">algebraicized Martin-Löf type theory</a> (not complete yet).</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><h3 id="Terms,-Patterns,-Rewrite-rules-1"><a class="docs-heading-anchor" href="#Terms,-Patterns,-Rewrite-rules-1">Terms, Patterns, Rewrite rules</a><a class="docs-heading-anchor-permalink" href="#Terms,-Patterns,-Rewrite-rules-1" title="Permalink"></a></h3><p>Take the theory of categories and let <code>Ob=Sort(:Ob); A,B,C,X,Y,Z = [Var(x, Ob) for x in [:A,:B,:C,:X,:Y,:Z]]</code> so that we can create a term: <code>Var(:f, Sort(:Hom,[A,B]))</code></p><iframe scrolling="no" style="height: 625px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/f.html" height="525" width="100%"></iframe><p>We can define composition by providing the output sort and then the sorts of arguments: <code>OpDecl(:cmp, Sort(:Hom,[X,Z]), [Sort(:Hom,[X,Y])]),Sort(:Hom,[Y,Z])])</code> Here the variables actually signify wildcards, so these terms gets automatically turned into patterns with named wildcards and a new dark cross symbol which means &quot;I have a term (arg #2) of a certain sort (arg #1)&quot;. This is what the output sort looks like:</p><iframe scrolling="no" style="height: 625px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/homxzpat.html" height="525" width="100%"></iframe><p>Now we can compute the sort of arbitrary expressions that match this pattern. So using a theory we can &quot;upgrade&quot; a term like <code>App(:cmp,[App(:id,[A]), Var(:f,Sort(:Hom,[A,B]))])</code>:</p><iframe scrolling="no" style="height: 625px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idf.html" height="525" width="100%"></iframe><p>...to a &quot;sorted version&quot;:</p><iframe scrolling="no" style="height: 625px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idfinferred.html" height="525" width="100%"></iframe><p>We can then create pattern out of this and <code>f</code> by itself to make a rule: <code>Rule(&quot;⋅ left-identity&quot;, f, App(:cmp, [idA,f]))</code> which can perform the left rewrite identity on any graph term of an identity composed with something.</p><h3 id="Normalization-rules-1"><a class="docs-heading-anchor" href="#Normalization-rules-1">Normalization rules</a><a class="docs-heading-anchor-permalink" href="#Normalization-rules-1" title="Permalink"></a></h3><p>A naive normalization algorithm is implemented to simplify terms, hopefully to a normal form (if the axioms, interpreted as rewrite rules, are confluent and terminating). It tries to apply all rules to all nodes in the tree, restarting when a change is made. If a cycle is detected, then the process stops and returns the lexicographic maximum (to resolve <code>(X+Y)&lt;-&gt;(Y+X)</code> infinite loops and others). Examples, including <code>((id(A) ⋅ ((ab ⋅ bc) ⋅ id(C))) ⋅ (id(C) ⋅ (id(C) ⋅ cd))) -&gt; ((ab ⋅ bc) ⋅ cd)</code>, are in a <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/test/testnorm.jl">test file</a>.</p><h3 id="Computing-with-GATs-1"><a class="docs-heading-anchor" href="#Computing-with-GATs-1">Computing with GATs</a><a class="docs-heading-anchor-permalink" href="#Computing-with-GATs-1" title="Permalink"></a></h3><p>We can define an instance of a theory by mapping (possibly parameterized) types to sorts and functions to the term operations. In a <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/test/testinst.jl">test file</a> there are examples of implementing Monoids with <code>(Int,*)</code>, Boolean algebras with the powerset of <code>{1,2,3}</code> and union/intersection/complement, and Categories with 2D matrix multiplication. For instance, the following term can be evaluated in an environment where <code>f=[1, 2, 3; 4, 5, 6], g=[1;1;1], M=ℤ², N=ℤ³, P=ℤ</code></p><iframe scrolling="no" style="height: 625px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idfg.html" height="525" width="100%"></iframe><p>to obtain the composite <code>[6; 15]</code> which transforms from ℤ² to ℤ. We can reduce the number of computations by reducing the expression using <code>Cat</code>&#39;s rewrite rules before evaluating.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 21 May 2020 01:18">Thursday 21 May 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
