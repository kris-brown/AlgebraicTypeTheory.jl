<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AlgebraicTypeTheory.jl Â· AlgebraicTypeTheory.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AlgebraicTypeTheory.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AlgebraicTypeTheory.jl</a><ul class="internal"><li><a class="tocitem" href="#Goals-1"><span>Goals</span></a></li><li><a class="tocitem" href="#Status-1"><span>Status</span></a></li><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AlgebraicTypeTheory.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AlgebraicTypeTheory.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AlgebraicTypeTheory.jl-1"><a class="docs-heading-anchor" href="#AlgebraicTypeTheory.jl-1">AlgebraicTypeTheory.jl</a><a class="docs-heading-anchor-permalink" href="#AlgebraicTypeTheory.jl-1" title="Permalink"></a></h1><p>So far, encoding material from <a href="http://www.jonmsterling.com/pdfs/algebraic-type-theory-tutorial.pdf">this tutorial</a> and <a href="https://arxiv.org/abs/1902.08848">this paper</a> by Jonathan Sterling.</p><h2 id="Goals-1"><a class="docs-heading-anchor" href="#Goals-1">Goals</a><a class="docs-heading-anchor-permalink" href="#Goals-1" title="Permalink"></a></h2><ul><li><p>[x] To experiment with ideas that might be useful for <a href="https://epatters.github.io/Catlab.jl/latest/">Catlab.jl</a>.</p></li><li><p>[x] To construct <em>theories</em>, which are collections of sort declarations, (term) operation declarations, and equality axioms (between sorts and/or terms).</p></li><li><p>[x] To <em>instantiate</em> theories using Julia types and functions, so that terms of the theory can be concretely evaluated.</p></li><li><p>[ \ ] To use a theory to rewrite terms of that theory in a normal form.</p></li><li><p>[  ] Test (by exhaustive or random search) that instances of theories satisfy their axioms</p></li><li><p>[  ] To represent homomorphisms between theories and to be able to compose these to get new instances from old ones.</p></li><li><p>[  ] To look at the structure of some theories and automatically infer some natural morphisms (e.g. an injection from a strictly smaller theory).</p></li><li><p>[  ] To organize a collection of theories into a queryable knowledge base.</p></li><li><p>[  ]To use macros to make the writing of equations/theories more convenient. E.g.</p></li></ul><pre><code class="language-none">   App(:mul, [
      App(:mul, [
         App(:mul, [
               App(:mul, [
                  App(:mul,[
                     App(:id),
                     X]),
                  Y]),
               Z]),
         App(:id)]),
      X])</code></pre><p>could be written as <code>@term (((((id() * X) * Y) * Z) * id()) * X)</code></p><h2 id="Status-1"><a class="docs-heading-anchor" href="#Status-1">Status</a><a class="docs-heading-anchor-permalink" href="#Status-1" title="Permalink"></a></h2><p>Theories: implementations for <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Boolean.jl">Boolean algebras</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Preorder.jl">preorders</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Monoid.jl">monoids</a>, <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Cat.jl">categories</a>, an <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/src/theories/Cwf_no_level.jl">algebraicized Martin-LÃ¶f type theory</a> (not complete yet).</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><h3 id="Terms,-Patterns,-Rewrite-rules-1"><a class="docs-heading-anchor" href="#Terms,-Patterns,-Rewrite-rules-1">Terms, Patterns, Rewrite rules</a><a class="docs-heading-anchor-permalink" href="#Terms,-Patterns,-Rewrite-rules-1" title="Permalink"></a></h3><p>Take the theory of categories and create a term: <code>Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:A,Ob)]))</code> (using <code>Ob=Sort(:Ob)</code>)</p><iframe style="height: 525px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/f.html" height="525" width="100%"></iframe><p>We can define composition by providing the output sort, <code>Sort(:Hom,[Var(:X,Ob),Var(:Z,Ob)])</code>. Here the variables actually are meant to be wildcards, so we can create a new symbol in our graph to mean &quot;something (arg #2) of a certain sort (arg #1)&quot; and let the &quot;something&quot; be matchable with anything.</p><iframe style="height: 525px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/homxzpat.html" height="525" width="100%"></iframe><p>The variable names were significant (note each wildcard has a name) since these names can be bound in the arguments of the declaration of composition, which are <code>Var(:m,Sort(:Hom,[Var(:X,Ob),Var(:Y,Ob)])])</code> and <code>Var(:n,Sort(:Hom,[Var(:Y,Ob),Var(:Z,Ob)])])</code> (the variable names <code>m</code> and <code>n</code> only matter for printing out the operator declaration, and all that was important for <code>Y</code> was that it was the same in the two arguments). Now we can compute the sort of arbitrary expressions that match this pattern. So using a theory we can &quot;upgrade&quot; a term like <code>App(:cmp,[App(:id,[Var(:A,Ob)]), Var(:f,Sort(:Hom,[Var(:A,Ob),Var(:B,Ob)]))])</code>:</p><iframe style="height: 525px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idf.html" height="525" width="100%"></iframe><p>...to a &quot;sorted version&quot;:</p><iframe style="height: 525px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idfinferred.html" height="525" width="100%"></iframe><p>We can then create pattern out of this and <code>f</code> by itself to make a rule: <code>Rule(&quot;â‹… left-identity&quot;, f, App(:cmp, [idA,f]))</code> which can perform the left rewrite identity on any graph term of an identity composed with something.</p><h3 id="Example-theory-1"><a class="docs-heading-anchor" href="#Example-theory-1">Example theory</a><a class="docs-heading-anchor-permalink" href="#Example-theory-1" title="Permalink"></a></h3><p>Sort declarations, term operation declarations, and axioms all can be rendered in plain text, and sorts/terms/patterns may as viewed as term graphs. For example, this fragment of categories with families + dependent types.</p><pre><code class="language-none">
################################
# ******* Theory: cwf ******* #
################################

4 sorts, 13 ops, 14 rules

#########
# Sorts #
#########

==================================================

---------   Ctx
Ctx  sort

Contexts: Concretely, a mapping xáµ¢:Xáµ¢ of free variables to types.
Consider these as objects in a category C.


==================================================
   Î“:Ctx
-----------   Ty
Ty(Î“)  sort

The sort of types in context Î“


==================================================
 A,B:Ctx
---------   Hom
Aâ†’B  sort

Substitutions between contexts: concretely, a substitution báµ¢:Î²áµ¢â†¦aáµ¢:Î±áµ¢.
Consider these as morphisms in the category C.


==================================================
A:Ty(Î“)  Î“:Ctx
--------------   el
ğ„ğ¥(Î“âŠ¢A)  sort

The sort of terms of type A (in ctx Î“), where A is of size Î±
 &#39;This is to fix a dependent presheaf El: Psh(ctx)/Ty, i.e. a nat. trans. Ï€: Elâ†’Ty&#39;


##############
# Operations #
##############

==================================================
A:Ty(Î“)  Î“:Ctx
--------------   ext
 (Î“.A) : Ctx

Context compreshension operation


==================================================
B:Ty((Î“.A))  A:Ty(Î“)  Î“:Ctx
---------------------------   Pi
      Î (A,B) : Ty(Î“)

Î  formation


==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  Î“,Î”:Ctx
-----------------------   Tyact
     A[Î³] : Ty(Î”)

Substitution action: apply the substitution Î³ (of type Î”â†’Î“) to a some type A (in ctx Î“) to obtain a term of type Î”


==================================================

-------   emp
â‹… : Ctx

The category C has a terminal object: the empty context


==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  Î“,Î”:Ctx  a:ğ„ğ¥(Î“âŠ¢A)
----------------------------------   Elact
        a[Î³] : ğ„ğ¥(Î”âŠ¢A[Î³])

Substitution action: apply the substitution Î³ (of type Î”â†’Î“) to a term of type A (in ctx Î“)
Result: a term of type A[Î³] (in ctx Î”)


==================================================
B:Ty((Î“.A))  A:Ty(Î“)  M:ğ„ğ¥((Î“.A)âŠ¢B)  Î“:Ctx
------------------------------------------   lam
           Î»(M) : ğ„ğ¥(Î“âŠ¢Î (A,B))

Î  introduction


==================================================
B:Ty((Î“.A))  A:Ty(Î“)  M:ğ„ğ¥(Î“âŠ¢Î (A,B))  N:ğ„ğ¥(Î“âŠ¢A[id(Î“)])  Î“:Ctx
-------------------------------------------------------------   app
                ğšğ©ğ©(M,N) : ğ„ğ¥(Î“âŠ¢B[âŸ¨id(Î“),NâŸ©])

Pi elimination via application

==================================================
f:Aâ†’B  g:Bâ†’C  A,B,C:Ctx
-----------------------   cmp
      (fâ‹…g) : Aâ†’C

Composition, only defined for pairs of morphisms that match head-to-tail, is an associative operation which picks out a third.

==================================================
    Î“:Ctx
--------------   empsubst
!(Î“) : Î“â†’emp()

Substitution into an empty context

==================================================
A:Ty(Î“)  Î“:Ctx
--------------   p
ğ©(A) : (Î“.A)â†’Î“

Projection function &#39;drop&#39;???

==================================================
     A:Ty(Î“)  Î“:Ctx
------------------------   q
ğª(A) : ğ„ğ¥((Î“.A)âŠ¢A[ğ©(A)])

Projection function &#39;var&#39;???


###################
# Equality Axioms #
###################
==================================================
  Î·:Î“â†’emp()  Î“:Ctx
--------------------   ! unique
!(Î“) = Î·   : Î“â†’emp()

Substitution into an empty context is unique.
==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  B:Ty((Î“.A))  M:ğ„ğ¥((Î“.A)âŠ¢B)  Î“,Î”:Ctx
---------------------------------------------------   Lambda Substitution
 Î»(M)[Î³] = M[âŸ¨(ğ©(A)â‹…Î³),ğª(A)âŸ©]   : ğ„ğ¥(Î”âŠ¢Î (A,B)[Î³])

==================================================
      Î³:Î”â†’Î“  A:Ty(Î“)  B:Ty((Î“.A))  Î“,Î”:Ctx
------------------------------------------------   Pi substitution
Î (A,B)[Î³] = Î (A[Î³],B[âŸ¨(ğ©(A)â‹…Î³),ğª(A)âŸ©])   : Ty(Î”)

==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  a:ğ„ğ¥(Î“âŠ¢A)  Î´:Îâ†’Î”  Î“,Î”,Î:Ctx
-------------------------------------------   Term substitution composition
   a[(Î´â‹…Î³)] = a[Î³][Î´]   : ğ„ğ¥(ÎâŠ¢A[(Î´â‹…Î³)])

The functor to Fam from C preserves composition of substitutions:
Applying two substitutions in sequence is the same as applying the composition of the substitutions in C
==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  N:ğ„ğ¥(Î”âŠ¢A[Î³])  Î“,Î”:Ctx
-------------------------------------   Universal property of ğ©
      Î³ = (âŸ¨Î³,NâŸ©â‹…ğ©(A))   : Î”â†’Î“

==================================================
Î³:Î”â†’Î“  A:Ty(Î“)  N:ğ„ğ¥(Î”âŠ¢A[Î³])  Î“,Î”:Ctx
-------------------------------------   Universal property of ğª
   N = ğª(A)[âŸ¨Î³,NâŸ©]   : ğ„ğ¥(Î”âŠ¢A[Î³])
==================================================
            A:Ty(Î“)  Î“:Ctx
---------------------------------------   ğ©ğª property
id((Î“.A)) = âŸ¨ğ©(A),ğª(A)âŸ©   : (Î“.A)â†’(Î“.A)</code></pre><h3 id="Normalization-rules-1"><a class="docs-heading-anchor" href="#Normalization-rules-1">Normalization rules</a><a class="docs-heading-anchor-permalink" href="#Normalization-rules-1" title="Permalink"></a></h3><p>A naive normalization algorithm is implemented to simplify terms, hopefully to a normal form (if the axioms, interpreted as rewrite rules, are confluent and terminating). It tries to apply all rules to all nodes in the tree, restarting when a change is made. If a cycle is detected, then the process stops and returns the lexicographic maximum (to resolve <code>(X+Y)&lt;-&gt;(Y+X)</code> infinite loops and others). Examples, including <code>((id(A) â‹… ((ab â‹… bc) â‹… id(C))) â‹… (id(C) â‹… (id(C) â‹… cd))) -&gt; ((ab â‹… bc) â‹… cd)</code>, are in a <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/test/testnorm.jl">test file</a>.</p><h3 id="Computing-with-GATs-1"><a class="docs-heading-anchor" href="#Computing-with-GATs-1">Computing with GATs</a><a class="docs-heading-anchor-permalink" href="#Computing-with-GATs-1" title="Permalink"></a></h3><p>We can define an instance of a theory by mapping (possibly parameterized) types to sorts and functions to the term operations. In a <a href="https://github.com/kris-brown/AlgebraicTypeTheory.jl/blob/master/test/testinst.jl">test file</a> there are examples of implementing Monoids with <code>(Int,*)</code>, Boolean algebras with the powerset of <code>{1,2,3}</code> and union/intersection/complement, and Categories with 2D matrix multiplication. For instance, the following term can be evaluated in an environment where <code>f=[1, 2, 3; 4, 5, 6], g=[1;1;1], M=â„¤Â², N=â„¤Â³, P=â„¤</code></p><iframe style="height: 525px;" id="igraph" style="border:none;" seamless="seamless" src="https://web.stanford.edu/~ksb/docs/idfg.html" height="525" width="100%"></iframe><p>to obtain the composite <code>[6; 15]</code> which transforms from â„¤Â² to â„¤. We can reduce the number of computations by reducing the expression using a one of rewrite rules before evaluating.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 16 March 2020 15:17">Monday 16 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
